# Default values for monitoring.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

prometheus:
  nodeExporter:
    enabled: false
  kubeStateMetrics:
    enabled: true

  server:
    global:
      scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
      evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
      # scrape_timeout is set to the global default (10s).

    retention: "31d"

    persistentVolume:
      enabled: true
      accessModes:
        - ReadWriteOnce
      size: 8Gi
      mountPath: /data

  serverFiles:
    # Alertmanager configuration
    alerting:
      alertmanagers:
      - static_configs:
        - targets:
          # - alertmanager:9093
    # Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
    prometheus.yml:
      rule_files:
        # - "first_rules.yml"
        # - "second_rules.yml"
      # A scrape configuration containing exactly one endpoint to scrape:
      # Here it's Prometheus itself.
      scrape_configs:

        - job_name: 'prometheus'
          scrape_interval: 5s
          static_configs:
            - targets: ['prysm-monitoring-prometheus-server:9090']
        - job_name: 'validator'
          scrape_interval: 5s
          static_configs:
            - targets: ['prysm-validator:8081']
        - job_name: 'beacon node'
          scrape_interval: 5s
          static_configs:
            - targets: ['prysm-beacon:8080']
        - job_name: 'slasher'
          scrape_interval: 5s
          static_configs:
            - targets: ['prysm-slasher:8082']

        - job_name: 'ping_google'
          metrics_path: /probe
          params:
            module: [icmp]
          static_configs:
            - targets:
              - 8.8.8.8
          relabel_configs:
            - source_labels: [__address__]
              target_label: __param_target
            - source_labels: [__param_target]
              target_label: instance
            - target_label: __address__
              replacement: prysm-monitoring-prometheus-blackbox-exporter:9115  # The blackbox exporter's real hostname:port.
        - job_name: 'ping_cloudflare'
          metrics_path: /probe
          params:
            module: [icmp]
          static_configs:
            - targets:
              - 1.1.1.1
          relabel_configs:
            - source_labels: [__address__]
              target_label: __param_target
            - source_labels: [__param_target]
              target_label: instance
            - target_label: __address__
              replacement: prysm-monitoring-prometheus-blackbox-exporter:9115  # The blackbox exporter's real hostname:port.
        # - job_name: json_exporter
        #   static_configs:
        #   - targets:
        #     - 127.0.0.1:7979
        # - job_name: json
        #   metrics_path: /probe
        #   static_configs:
        #   - targets:
        #     - https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd
        #   relabel_configs:
        #   - source_labels: [__address__]
        #     target_label: __param_target
        #   - source_labels: [__param_target]
        #     target_label: instance
        #   - target_label: __address__
        #     replacement: 127.0.0.1:7979

grafana:
  adminUser: admin
  adminPassword: meepmeepchange

  service:
    type: ClusterIP
    port: 80
    targetPort: 3000
      # targetPort: 4181 To be used with a proxy extraContainer
    annotations: {}
    labels: {}
    portName: service

  persistence:
    type: pvc
    enabled: true
    # storageClassName: default
    accessModes:
      - ReadWriteOnce
    size: 1Gi
    # annotations: {}
    finalizers:
      - kubernetes.io/pvc-protection
    # subPath: ""
    # existingClaim:

  extraExposePorts: []
  # - name: keycloak
  #   port: 8080
  #   targetPort: 8080
  #   type: ClusterIP

  # overrides pod.spec.hostAliases in the grafana deployment's pods
  hostAliases: []
    # - ip: "1.2.3.4"
    #   hostnames:
    #     - "my.host.com"

  ingress:
    enabled: false
    # Values can be templated
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    labels: {}
    path: /
    hosts: []
    ## Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
    extraPaths: []
    # - path: /*
    #   backend:
    #     serviceName: ssl-redirect
    #     servicePort: use-annotation
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

replicaCount: 0

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 3000

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host:
      paths: []
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
